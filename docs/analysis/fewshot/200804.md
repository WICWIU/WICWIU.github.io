이곳은 **fewshot-learning** 을 구현하기 위한 [**WICWIU**](https://github.com/WICWIU/WICWIU) 개발팀의 [**WICWIU**](https://github.com/WICWIU/WICWIU) 분석 과정을 기록해두는 곳입니다.

# Coding: CasiaWebFace Image to vector

## Coding: `getDirList` 함수

먼저 **CasiaWebFace** 이미지를 자동으로 읽어오기 위하여 디렉토리 리스트를 얻을 수 있는 코드를 짰습니다.

```c++ linenums="1"
#include <string>
#include <iostream>
#include <fstream>
#include <iterator>
#include <vector>
#include <dirent.h>
#include <sys/types.h>

DIR* getDirList(const char * dirName)
{
    DIR *dir;
    if ((dir = opendir(dirName)) == NULL)
        throw std::invalid_argument("could not open directory");
    return dir;
}
```

- **11~14**:

    `getDirList` 함수에 디렉토리 경로를 입력하면 디렉토리 내부 파일 정보를 갖고 있는 `DIR` 포인터를 반환합니다. 

    이 함수를 사용하여 다음과 같이 **CasiaWebFace** 이미지가 저장되어 있는 `/tmp/casia_train` 디렉토리의 내부 파일을 반환받는 코드를 짤 수 있습니다.

## Coding: `test_getDirList` 함수

!!! info

    `test_getDirList` 함수의 `test_` 는 **camel case** 가 아닌 **snake case** 로 되어있는데, 테스트 코드임을 강조하기 위하여 그렇게 한 것입니다. 나머지 코드는 모두 **camel case** 로 코딩되어 있습니다.

```c++ linenums="1"
void test_getDirList(bool error=false);

int main(int argc, char const *argv[])
{
    test_getDirList();
    return EXIT_SUCCESS;
}

void test_getDirList(bool error)
{
    DIR* dir;
    try
    {
        dir = (error) ?\
            getDirList("aweoifjaowief") :\
            dir = getDirList("/tmp/casia_train");
        struct dirent *ent;

        while ((ent = readdir(dir)) != NULL)
        {
            std::cout << ent->d_name << std::endl;
        }
        closedir(dir);
    } 
    catch (const std::invalid_argument& e)
    {
        std::cerr << e.what() << std::endl;
    }
}
```

- **1**:

    `test_getDirList` 는 `error` 인자를 받는데 `false` 가 기본값으로 설정되어 있습니다. 

- **14~21**:

    `error = false` 인  경우 `/tmp/casia_train` 디렉토리 내부 파일들을 출력합니다. 

- **14~21**:

    `error` 를 `true` 로 설정한다면 의도적으로 에러를 발생시키는 코드가 됩니다. 즉, 존재하지 않는 파일 경로를 `getDirList` 함수에 입력하여 에러를 발생시켜서 에러 처리 코드(`try~catch`) 가 잘 작동하는지 검증하는 것입니다.

## Coding: `test_getFirstCasiaImage` 함수

```c++ linenums="1"
void test_getFirstCasiaTrainImage();

int main(int argc, char const *argv[])
{
    test_getFirstCasiaTrainImage();
    return EXIT_SUCCESS;
}

void test_getFirstCasiaTrainImage()
{
    DIR * dir;
    std::string casiaTrainDirPath = "/tmp/casia_train";
    std::string casiaTrainFirstDirPath;
    std::string casiaTrainFirstImagePath;

    //
    // Get first directory of casia_train
    //
    try
    {
        dir = getDirList(casiaTrainDirPath.c_str());
        if (dir == nullptr)
            throw;
        struct dirent *ent;

        for (int idx = 0; (ent = readdir(dir)) != NULL; idx++)
        {
            if (idx == 2) // first index (because: 0 -> . 1 -> .. 2 -> first path)
            {
                casiaTrainFirstDirPath = casiaTrainDirPath + "/" + std::string(ent->d_name);
            }
        }
        closedir(dir);
    } 
    catch (const std::invalid_argument& e)
    {
        std::cerr << e.what() << std::endl;
    }

    //
    // Get first image of first directory
    //
    try
    {
        dir = getDirList(casiaTrainFirstDirPath.c_str());
        if (dir == nullptr)
            throw;
        struct dirent *ent;

        for (int idx = 0; (ent = readdir(dir)) != NULL; idx++)
        {
            if (idx == 2) // first index (because: 0 -> . 1 -> .. 2 -> first path)
            {
                casiaTrainFirstImagePath = casiaTrainFirstDirPath + "/" +std::string(ent->d_name);
            }
        }
        closedir(dir);
    } 
    catch (const std::invalid_argument& e)
    {
        std::cerr << e.what() << std::endl;
    }

    //
    // Convert image to vector<unsigned char>
    //
    std::ifstream casiaTrainFirstImage(casiaTrainFirstImagePath, std::ios::binary);
    std::vector<unsigned char> casiaTrainFirstImageBuffer(std::istreambuf_iterator<char>(casiaTrainFirstImage), {});
    
    //
    // Show result and converted image
    //
    std::cout << "First image of first caisa_train sub directory:" << std::endl;
    std::cout << '\t' << casiaTrainFirstImagePath  << std::endl;
    std::cout << "casiaTrainFirstImageBuffer size: " << std::endl;
    std::cout << '\t' << casiaTrainFirstImageBuffer.size() << std::endl;
    std::cout << "First 10 bytes:" << std::endl;
    std::cout << "\t";
    int ct=0;
    for (const auto byte: casiaTrainFirstImageBuffer)
    {
        if (ct < 10)
            std::cout << static_cast<int>(byte) << ' ';
        ct++;
    }
    std::cout << std::endl;
}
```

이후 `getDirList` 함수를 활용하여 `/tmp/casia_train` 의 첫번째 디렉토리의 첫번째 이미지를 읽어보는 테스트 코드를 작성했습니다. 

- **19~39**:

    `/tmp/casia_train` 의 첫번째 디렉토리 경로를 `casiaTrainFirstDirPath` 에 저장합니다.

- **42~61**:

    `/tmp/casia_train` 의 첫번째 디렉토리의 첫번째 이미지 경로를 `casiaTrainFirstImagePath` 에 저장합니다.

- **66~67**:

    `/tmp/casia_train` 의 첫번째 디렉토리의 첫번째 이미지를 바이너리로 읽고 `unsigned char` 자료형을 갖는 `vector` 로 변환합니다.

- **82~87**:

    이미지의 첫 `10` 바이트를 읽고 `int` 로 형변환하여 출력해봅니다. 그냥 잘 읽혔는지 확인하는 테스트 코드입니다.

!!! info

    [**WICWIU**](https://github.com/WICWIU/WICWIU) 는 `C++` 프로젝트이기 때문에 `C` 스타일로 코딩하는 것이 아니라 `C++` 스타일로 코딩하려고 노력하고 있습니다. 

    예를 들어서 다음 코드는 `C` 스타일 형변환입니다.

    ```c
    for (const auto byte: casiaTrainFirstImageBuffer)
    {
        std::cout << (int)(byte) << ' ';
    }
    ```

    다음 코드는 `C++` 스타일 형변환입니다.

    ```c
    for (const auto byte: casiaTrainFirstImageBuffer)
    {
        std::cout << static_cast<int>(byte) << ' ';
    }
    ```

    `C++` 프로젝트에서 `C` 스타일로 코딩하면 구닥다리 코드를 짠다고 욕먹을 수도 있고 심할 경우 프로젝트 안정성에 문제가 생길 수도 있기 때문에 주의하려구요. 다음 링크를 참조하면 `C++` 코딩 스타일 등에 대한 좋은 정보를 얻을 수 있습니다.

    - https://github.com/AnthonyCalandra/modern-cpp-features

    - https://github.com/isocpp/CppCoreGuidelines

    - https://github.com/lefticus/cppbestpractices

---

# Analysis: LFW Dataset, LFW Data Reader

저희 fewshot 팀은 LFW 팀이 개발해둔 코드를 참고할 수 있기 때문에 먼저 LFW 코드를 분석했습니다. [**WICWIU**](https://github.com/WICWIU/WICWIU) 개발 가이드의 [**WICWIU 로 학습하기**](../../../dev/wicwiu/learn.md) 의 첫번째 과정이 **Step 1. 학습 데이터 &rarr; `Tensor`** 이기 때문에 저희는 가장 먼저 학습시켜야할 데이터셋인 **Casia Web Face** 를 `Tensor` 로 변환해야 했습니다. 그래서 LFW 팀의 코드에서 데이터셋을 `Tensor` 로 변환하는 코드 흐름을 중점으로 분석을 시도해보았습니다.

## Analysis: `tutorials/LFW/main.cpp`

!!! info 

    `...` 은 생략된 코드를 뜻합니다!

```c++ linenums="1" hl_lines="14-15 31 70"
...
#define NUMBER_OF_CLASS               5749          // for lfw_funneled
...
int main(int argc, char const *argv[])
{
...
    Tensorholder<float> *x     = new Tensorholder<float>(1, BATCH, 1, 1, 145200, "x");
    Tensorholder<float> *label = new Tensorholder<float>(1, BATCH, 1, 1, NUMBER_OF_CLASS, "label");

    // ======================= Select net ===================
    NeuralNetwork<float> *net = new my_FaceNet<float>(x, label, NUMBER_OF_CLASS);
...
    vision::Compose *transform = new vision::Compose({new vision::Resize(224), new vision::CenterCrop(220)});
    LFWDataset<float> *train_dataset = new LFWDataset<float>("./data", "lfw_funneled", NUMBER_OF_CLASS, transform);
    DataLoader<float> *train_dataloader = new LFWSampler<float>(NUMBER_OF_CLASS, train_dataset, BATCH, TRUE, 1, FALSE);
...
    for (int epoch = startEpoch + 1; epoch < EPOCH; epoch++) {
        std::cout << "epoch : " << epoch << '\n';

#ifdef ENABLE_TRAINING
        if(epoch == startEpoch + 1 || (epoch - 1) % pos_neg_cycle == 0){
            train_dataset->GetPositiveIndices().resize(train_dataset->GetLength());
            train_dataset->GetNegativeIndices().resize(train_dataset->GetLength());

            FindPostiveNegativeSamples(net, INPUT_DIM, *train_dataset, FEATURE_DIM, BLOCK_SIZE, BATCH,
                                     &train_dataset->GetPositiveIndices()[0], &train_dataset->GetNegativeIndices()[0]);
...
```

- **14-15**:

    `main` 함수에서는 위에서 강조한 코드에서처럼 `LFWDataset` 을 생성하고 `LFWSampler` 를 만듭니다. 

```c++ linenums="1" hl_lines="5"
...
        // ======================= Train =======================
        net->SetModeTrain();
        for (int j = 0; j < loop_for_train; j++) {
            std::vector<Tensor<float> *> * temp =  train_dataloader->GetDataFromGlobalBuffer();

    #ifdef __CUDNN__
            (*temp)[0]->SetDeviceGPU(GPUID); 
            (*temp)[1]->SetDeviceGPU(GPUID);
    #endif  // __CUDNN__

            net->FeedInputTensor(2, (*temp)[0], (*temp)[1]);

            delete temp;
            temp = NULL;
...
        }
...
```

- **5**:

    학습할 때에는 `LFWSampler->GetDataFromBuffer` 로 데이터셋을 가져왔습니다. 

```c++ linenums="1" hl_lines="25"
...
        // ======================= Test ======================
...
#ifdef ENABLE_TEST
        net->SetModeInference();
...
        LFWDataset<float> &dataset = *train_dataset;      // only for debug
...
        int noTestSample = dataset.GetLength();
...
        std::vector<float*> vTestSample;
        std::vector<float*> vTestFeature;

		vPosIndex.resize(dataset.GetLength());
		vNegIndex.resize(dataset.GetLength());

        for(int batchIdx = 0; batchIdx < noBatch; batchIdx++){
            int curBatch = MIN(remained, BATCH);

            // extract feature using CNN
            AllocFeatureVector(INPUT_DIM, curBatch, vTestSample);
            AllocFeatureVector(FEATURE_DIM, curBatch, vTestFeature);

            for(int i = 0; i < curBatch; i++){
                dataset.CopyData(batchIdx * BATCH + i, vTestSample[i]);
            }

			net->InputToFeature(INPUT_DIM, vTestSample.size(), &vTestSample[0], FEATURE_DIM, &vTestFeature[0], BATCH);

            for(int i = 0; i < curBatch; i++){
                int result = knn.Recognize(vTestFeature[i], KNN_K);                
                if(result == dataset.GetLabel(batchIdx * BATCH + i))
                    correct++;
            }

            DeleteFeatureVector(vTestFeature);
            DeleteFeatureVector(vTestSample);

            remained -= curBatch;

            if((batchIdx + 1) % 10 == 0){
                printf("batch = %d / %d test accuracy = %f (%d / %d)\n", batchIdx + 1, noBatch,  correct / (float)(batchIdx * BATCH + curBatch), correct, batchIdx * BATCH + curBatch);
                fflush(stdout);
            }
        }
...
```

- **25**:

    테스트를 할 때에는 `LFWDataset->CopyData` 로 데이터셋을 가져옵니다.

그러니까 이제 `LFWDataset` 과 `LFWSampler`, 그리고 `LFWDataset::CopyData` 와 `LFWSampler::GetDataFromBuffer` 를 분석해야겠습니다.

## Analysis: `tutorials/LFW/LFWDataset.hpp`

```c++ linenums="1"
...
template<typename DTYPE>
class LFWDataset : public Dataset<DTYPE>{
private:
    int m_numOfImg;
    std::string m_rootPath;
    std::string m_dataPath;
    vision::Compose *m_transform;
    sem_t sem;

    // set of name of Class
    int m_useClasNum;
    std::vector<std::string> m_className;
    std::vector<std::string> m_aImagePath;
    std::vector<int> m_vSamplePerClass;
    int trigger;
    int imgNum[20];
...
public:
    LFWDataset(std::string rootPath, std::string dataPath, int useClassNum, vision::Compose *transform) {
        m_rootPath   = rootPath;
        m_dataPath   = dataPath;
        m_useClasNum = useClassNum;
        m_numOfImg = 0;
        trigger      = 0;
        m_transform  = transform;
        assert(m_transform != NULL);

        Alloc();
        CheckClassList();
        CreateImageListOfEachClass();

        LogMessageF("lfw_funneled_label.txt", TRUE, "%d samples\n", this->GetLength());
        CountSamplePerClass();
    }
...
```

- **3**:

    클래스 분석의 시작은 클래스 정의 형태와 생성자를 분석하는 것이므로 클래스 정의 형태를 살펴봅니다. `Dataset<DTYPE>` 을 상속받는 클래스 템플릿으로 선언되어 있넹.

- **21~23** 

    멤버 이니셜라이저를 사용하면 성능이 더 좋아지니까 나중에 바꿔야 할 듯하네요~

- **29**:

    `Alloc` 은 다음과 같이 간단히 정의되어 있었어요.

    ```c++
    template<typename DTYPE> void LFWDataset<DTYPE>::Alloc()  { sem_init(&sem, 0, 1);}
    ```

- **30**:

    `CheckClassList` 는 다음과 같이 정의되어 있네요.

    ```c++
    template<typename DTYPE> void LFWDataset<DTYPE>::CheckClassList() {
        // mnt/ssd/Data/ImageNet/synset_words.txt
        std::string filePath = m_rootPath + "/" + m_dataPath + ".txt";
        const char *cstr     = filePath.c_str();
        FILE *pFile = NULL;
        pFile = fopen(cstr, "r");
        ...
            char realValue[100];

            for (int i = 0; i < m_useClasNum; i++) {
                if (fscanf(pFile, "%s", realValue)) {
                    m_className.push_back((std::string)realValue);
                    while (fgetc(pFile) != '\n') ;
                } else {
                    printf("there is something error\n");
                    exit(-1);
                }
            }
        ...
        fclose(pFile);
    }
    ```

    `filePath` 를 읽어서 한줄씩 `m_className` 에 저장하고 있습니다.

    근데 `C` 스타일로 코딩된 것이 많아서 나중에 `C++` 스타일로 고쳐야겠다.

- **31**:

    `CreateImageListOfEachClass()` 는 다음과 같이 정의되어있네.

    ```c++ linenums="1"
    template<typename DTYPE> void LFWDataset<DTYPE>::CreateImageListOfEachClass() {
        std::vector<int> vTmpLabel;
        vTmpLabel.reserve(2048);

        for (int classNum = 0; classNum < m_useClasNum; classNum++) {
            std::string filePath = m_rootPath + '/' + m_dataPath + '/' + m_className[classNum] + "/list.txt";  // check with printf
            const char *cstr     = filePath.c_str();

            FILE *pFile = NULL;
            pFile = fopen(cstr, "r");

            char realValue[100];
            int  numOfImageOfClass = 0;
            ...
                if (fscanf(pFile, "%s", realValue)) {  // first realValue is already readed above
                    numOfImageOfClass = atoi(realValue);

                    for (int imageNum = 0; imageNum < numOfImageOfClass; imageNum++) {
                        if (fscanf(pFile, "%s", realValue)) {
                            m_aImagePath.push_back((std::string)(m_className[classNum] + '/' + realValue));
                            vTmpLabel.push_back(classNum);
                        } else {
                            printf("there is something error\n");
                            exit(-1);
                        }
                    }
                } else {
                    printf("there is something error\n");
                    exit(-1);
                }
            ...
            fclose(pFile);
        }
        m_numOfImg = m_aImagePath.size();
        this->SetLabel(&vTmpLabel[0], m_numOfImg);
        assert(m_numOfImg > 0);
    }   
    ```

    - **3**:
    
        https://en.cppreference.com/w/cpp/container/vector/reserve 에 `std::vector<T,Allocator>::reserve` 내용이 있는데 비용이 많이 들어가는 메모리 할당을 필요한 만큼 하도록 해서 속도도 높이고, 메모리 효율도 챙기는 좋은 코드인듯해요.
    
    - **6~16**:

        그러고 난 후 `m_rootPath/m_datapath/m_className[classNum]/list.txt` 를 읽어서 `pFile` 로 파일을 열고 한줄을 `realValue` 에 저장합니다. 이것을 `atoi` 함수로 `int` 로 변환하여 `numOfImageOfClass` 에 저장하네요.

    - **18~21**:

        그리고 `numOfImageOfClass` 만큼 `for` 문을 돌면서 `pFile` 다음 라인을 `realValue` 에 읽고 `(std::string)(m_className[classNum] + '/' + realValue)` 형태를 `m_aImagePath` 에 저장합니다. 그리고 `vTmpLabel` 에 `classNum` 을 저장합니다.

    - **34~35**:

        마지막으로 `m_aImagePath` 벡터 사이즈를 갖고 와서 `m_numOfImg` 에 저장하고 `SetLabel` 함수에 `vTmpLabel` 의 주소값과 함께 전달해줍니다.
    
    이미지 경로와 클래스 라벨을 벡터에 잘 저장해주는 함수라는 것을 알 수 있습니다.

- ** ** 

## Analysis: Shape.cpp Shape.hpp

## Analysis: Tensor.cpp